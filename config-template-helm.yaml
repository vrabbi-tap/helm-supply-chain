apiVersion: carto.run/v1alpha1
kind: ClusterConfigTemplate
metadata:
  labels:
    app.tanzu.vmware.com/deliverable-type: helm
  name: config-template-helm
spec:
  configPath: .data
  healthRule:
    alwaysHealthy: {}
  ytt: |
    #! load the needed ytt libraries for our functions
    #@ load("@ytt:data", "data")
    #@ load("@ytt:yaml", "yaml")
    #@ load("@ytt:overlay", "overlay")
    #@ load("@ytt:regexp", "regexp")
    
    #! add all workload labels to the fixed values in this 
    #! template as well for the stamped out configmap
    #@ def merge_labels(fixed_values):
    #@   labels = {}
    #@   if hasattr(data.values.workload.metadata, "labels"):
    #@     labels.update(data.values.workload.metadata.labels)
    #@   end
    #@   labels.update(fixed_values)
    #@   return labels
    #@ end
    
    #! used when the image_key_path param is specified
    #! recieves a list and a value and generates a yaml from the list
    #! and makes the final keys value the leaf
    #@ def as_dict(parts, leaf):
    #@   if len(parts) == 0:
    #@     return leaf
    #@   end
    #@   return {parts[0]: as_dict(parts[1:], leaf)}
    #@ end
    
    #! used when the image_key_path param is specified
    #! converts a "." seperated string into an array while taking into account 
    #! escaped "." chars via a "\" char.
    #@ def split_dot_path(path):
    #@   # "replace any dot that does NOT have a leading slash with ':::'
    #@   path = regexp.replace("([^\\\])\.", path, "$1:::")
    #@   path = path.replace("\.", ".")   # consume escaping of '.'
    #@   return path.split(":::")
    #@ end
    
    #! returns the image path for the helm values where we should place
    #! the new image reference generated by the supply chain.
    #! this includes defaulting to "image.repository" as the path.
    #@ def image_path():
    #@   if hasattr(data.values.params, "image_key_path"):
    #@     return data.values.params.image_key_path
    #@   else:
    #@     return "image.repository"
    #@   end
    #@ end
    
    #! generate the yaml config for the image oath in the chart values
    #@ chart_config = as_dict(split_dot_path(image_path()), data.values.config.spec.containers[0].image)
    
    #! Define a function that returns the parameters supplied via carotgrapher
    #@ def chart_overrides():
    #@   return data.values.params
    #@ end
    
    #! define a function that generates the image overlay yaml for the
    #! helm chart values, and superseeds it with the missing ok annotation.
    #! this is needed to support situations where keys may or may not exist
    #! already in the chart_values provided via the parameters
    #@ def image_override():
    #@overlay/match-child-defaults missing_ok=True
      chart_values: #@ chart_config
    #@ end
    
    #! this function merges the user supplied chart values and the 
    #! image overlay yamls, and returns the final chart values struct
    #! which we can use in the helm release CR.
    #@ def chart_values():
    #@   if hasattr(data.values.params, "chart_values"):
    #@     return overlay.apply(chart_overrides(), image_override())["chart_values"]
    #@   else:
    #@     return image_override()["chart_values"]
    #@   end
    #@ end
    
    #! this function templates out the helm release manifest using supplied data values
    #! as well as the functions defined above.
    #@ def helm_release():
    ---
    apiVersion: helm.toolkit.fluxcd.io/v2beta1
    kind: HelmRelease
    metadata:
      name: #@ data.values.workload.metadata.name
      namespace: #@ data.values.workload.metadata.namespace
      labels: #@ merge_labels({ "app.kubernetes.io/component": "helm-release", "app.tanzu.vmware.com/release-type": "helm" })
    spec:
      interval: 5m
      chart:
        spec:
          chart: #@ data.values.params.chart_name
          #@ if/end hasattr(data.values.params, "chart_version"):
          version: #@ data.values.params.chart_version
          sourceRef:
            kind: #@ data.values.params.chart_repo.kind
            name: #@ data.values.params.chart_repo.name
            #@ if/end hasattr(data.values.params.chart_repo, "namespace"):
            namespace: #@ data.values.params.chart_repo.namespace
          interval: 1m
      upgrade:
        remediation:
          remediateLastFailure: true
      values: #@ chart_values()
    #@ end
    
    #! Stamping out of the final yaml which is a configmap that will contain the
    #! helm release manifest we have templated above.
    ---
    apiVersion: v1
    kind: ConfigMap
    metadata:
      name: #@ "{}-helm-release".format(data.values.workload.metadata.name)
      labels: #@ merge_labels({ "app.kubernetes.io/component": "config" })
    data:
      helm-release.yaml: #@ yaml.encode(helm_release())
